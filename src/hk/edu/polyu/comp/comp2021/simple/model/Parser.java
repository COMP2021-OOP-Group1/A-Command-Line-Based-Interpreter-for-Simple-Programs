package hk.edu.polyu.comp.comp2021.simple.model;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Parser {
    public static Map<Integer, String> cmdMap = new HashMap<>();
    public static Map<String, String> labelCMDMap = new HashMap<>();  // Stores Labels and its commands (Label - Command)
    public static Map<String, String> expRefLabelCmd = new HashMap<>();  // Stores expRefs and its commands (Label - Command)
    public static Map<String, Object> varMap = new HashMap<>();   // Stores Variables and Values (Variable - Value)  // Stores Variables and Bool Values (Variable - Value)
    public static Map<String, Object> resultExp = new HashMap<>();   // Stores Results of Expressions (Label - Result)
    public static Map<String, String[]> blockMap = new HashMap<>(); // Stores block of commands (Label - Command Block)
    public static Map<String, String> programMap = new HashMap<>(); // Stores the programName and the label of command

    public static int count = 0;
    public static String breakPointLabel = "";

    public static void storeCommand(String command){

        // Check if instruction is valid first
        String[] splitStr = command.split(" ");  // Split instruction into words

        if (splitStr[0].equals("vardef")){
            cmdMap.put(count, command);
            labelCMDMap.put(splitStr[1], command);
            classification(command);
        }
        else if (splitStr[0].equals("binexpr") || splitStr[0].equals("unexpr")){
            cmdMap.put(count, command);
            expRefLabelCmd.put(splitStr[1], command);
            classification(command);
            Simple.updateExp();
        }
        else if (splitStr[0].equals("block")){
            String[] instructions = Arrays.copyOfRange(splitStr, 2, splitStr.length);
            blockMap.put(splitStr[1], instructions);
            cmdMap.put(count, command);
            labelCMDMap.put(splitStr[1], command);
        }
        else if (splitStr[0].equals("program") || splitStr[0].equals("execute") || splitStr[0].equals("list") || splitStr[0].equals("store") || splitStr[0].equals("load")){
            cmdMap.put(count, command);
            classification(command);
        }
        else{
            cmdMap.put(count, command);
            labelCMDMap.put(splitStr[1], command);
        }

    }

    public static void classification(String command) {

        // Classify the commands

        String[] splitStr = command.split(" ");  // Split instruction into words
        String instruction = splitStr[0];

        /*
        // If input is just a label name:
        if (splitStr.length == 1){
            // Fix when command do not have label
            if (resultExp.containsKey(instruction)) resultExp.get(instruction);
            else classification(labelCMDMap.get(instruction));   // Do instruction of the label
        }
        */
        
        // Call Commands based on the instruction
        switch (instruction) {
            
            case "vardef":  //* REQ1
                Simple.vardef(splitStr);
                break;
            
            case "binexpr": //* REQ2
                Simple.binExpr(splitStr);
                break;
            
            case "unexpr":  //* REQ3
                Simple.unexpr(splitStr[1], splitStr[2], splitStr[3]);
                break;

            case "assign":  //* REQ4
                Simple.assign(splitStr[2], splitStr[3]);
                break;

            case "print":   //* REQ5   
                Simple.print(splitStr[1], splitStr[2]);
                break;

            case "skip":    //* REQ6
                Simple.skip();
                break;

            case "block":   //* REQ7
                String[] instructions = Arrays.copyOfRange(splitStr, 2, splitStr.length);
                Simple.block(instructions);
                break;
                
            case "if":  //* REQ8
                Simple.ifF(splitStr[2], splitStr[3], splitStr[4]);
                break;

            case "while":   //* REQ9
                Simple.whileW(splitStr[2], splitStr[3]);
                break;

            case "program": //* REQ10
                Simple.program(splitStr[1], splitStr[2]);
                break;

            case "execute": //* REQ11
                Simple.execute(splitStr[1]);
                break;

            case "list":    //* REQ12
                Simple.list(programMap.get(splitStr[1]));
                break;

            case "store":   //* REQ13
                // Generated by vs-code
                try { File.store(splitStr[1], splitStr[2]);} 
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                break;

            case "load":    //* REQ1
                try { File.load(splitStr[1],splitStr[2]);} 
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                break;

            case "debug":
                break;

            case "togglebreakpoint":
                Simple.togglebreakpoint(splitStr[1],splitStr[2]);
                break;

        }

    }

    public void storeCMDtoFile() {

    }

    public static Object expRef(String expression){    // Check if the expression is a literal, var name or expression name.
        
        // If expression is a literal
        if (expression.equals("true")) return true;
        else if (expression.equals("false")) return false;

        
        // If expRef is a variable return variable from map
        if (varMap.containsKey(expression)) return varMap.get(expression);
            
        // If variable is expression reference
        if (resultExp.containsKey(expression)){
            if (resultExp.get(expression) instanceof Integer){return (int) resultExp.get(expression);}
            else return (boolean)resultExp.get(expression);
        }

        try{return Integer.parseInt(expression);}
        catch (Exception NumberFormatException){}

        return null;

    }

    public static void addResultExp(String label, Object object){resultExp.put(label, object);}

    // Use for input command, but just model, Application will be call this
    public void inputCMD() {

        Scanner inputLine = new Scanner(System.in);

        while(inputLine.hasNextLine()){

            String input = inputLine.nextLine();
            if (input != null){
                count++;
                if (input.equals("quit")) System.exit(0);
                storeCommand(input);
                // classification(input);
            }

        }

        inputLine.close();
    }

    //! Separate store instructions and execute instructions in if while print block cases

}
