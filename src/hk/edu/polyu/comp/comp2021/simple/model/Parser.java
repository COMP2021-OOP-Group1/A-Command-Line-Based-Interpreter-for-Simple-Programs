package hk.edu.polyu.comp.comp2021.simple.model;

import java.io.IOException;
import java.util.*;

/**
 * For control the model Simple.java and Data.java
 */
public class Parser {

    /**
     * Java Encapsulation from Data class
     */
    protected static Data data = new Data();

    /**
     * Get from Data.java
     */
    protected static Map<String, String> labelCMDMap = data.getLabelCMDMap();
    /**
     * Get from Data.java
     */
    protected static Map<String, String> expRefLabelCmd = data.getExpRefLabelCmd();
    /**
     * Get from Data.java
     */
    protected static Map<String, String> breakPointMap = data.getBreakPointMap();
    /**
     * Get from Data.java
     */
    protected static Map<String, List<Object>> varHistoryMap = data.getVarHistoryMap();
    /**
     * Get from Data.java
     */
    protected static Map<String, Object> varMap = data.getVarMap();
    /**
     * Get from Data.java
     */
    protected static Map<String, String> programMap = data.getProgramMap();
    /**
     * Get from Data.java
     */
    protected static Map<String, Object> resultExp = data.getResultExp();


    protected static Map<String, ArrayList<String>> debugger = data.getDebugger();  // Gabe




    /**
     *
     * @param command: the commands input by user
     */
    public static void classification(String command, String programName) {

        // Classify the commands

        String[] splitStr = command.split(" ");  // Split instruction into words
        String instruction = splitStr[0];

        if (debugger.containsKey(programName)) Simple.waitDebug(programName);
        
        // Call Commands based on the instruction
        switch (instruction) {
            
            case "vardef":  //* REQ1
                Simple.vardef(splitStr);
                break;
            
            case "binexpr": //* REQ2
                Simple.binExpr(splitStr);
                break;
            
            case "unexpr":  //* REQ3
                Simple.unexpr(splitStr[1], splitStr[2], splitStr[3]);
                break;

            case "assign":  //* REQ4
                Simple.assign(splitStr[2], splitStr[3]);
                break;

            case "print":   //* REQ5   
                Simple.print(splitStr[1], splitStr[2]);
                break;

            case "skip":    //* REQ6
                Simple.skip();
                break;

            case "block":   //* REQ7
                String[] instructions = Arrays.copyOfRange(splitStr, 2, splitStr.length);
                Simple.block(instructions);
                break;
                
            case "if":  //* REQ8
                Simple.ifF(splitStr[2], splitStr[3], splitStr[4]);
                break;

            case "while":   //* REQ9
                Simple.whileW(splitStr[2], splitStr[3]);
                break;

            case "program": //* REQ10
                Simple.program(splitStr[1], splitStr[2]);
                break;

            case "execute": //* REQ11
                Simple.execute(splitStr[1]);
                System.out.println();
                break;

            case "list":    //* REQ12
                System.out.println("\nList of commands in " + splitStr[1] + ":\n");
                Simple.list(programMap.get(splitStr[1]), new ArrayList<String>());
                break;

            case "store":   //* REQ13
                // Generated by vs-code
                try { Simple.store(splitStr[1], splitStr[2]);} 
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                break;

            case "load":    //* REQ14
                try { Simple.load(splitStr[1],splitStr[2]);} 
                catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                break;

            case "debug":
                Simple.debug(splitStr[1]);
                break;

            case "togglebreakpoint":
                Simple.togglebreakpoint(splitStr[1],splitStr[2]);
                break;

            case "inspect":
                Simple.inspect(splitStr);
                break;

        }

    }

    /**
     * expRef function is check if the expression is a literal, var name or expression name
     * @param expression: the expression statement
     * @return the result of expression
     */
    public static Object expRef(String expression){    // Check if the expression is a literal, var name or expression name.
        
        // If expression is a literal
        if (expression.equals("true")) return true;
        else if (expression.equals("false")) return false;

        
        // If expRef is a variable return variable from map
        if (varMap.containsKey(expression)) return varMap.get(expression);
            
        // If variable is expression reference
        if (resultExp.containsKey(expression)){
            if (resultExp.get(expression) instanceof Integer){return (int) resultExp.get(expression);}
            else return (boolean)resultExp.get(expression);
        }

        try{
            if (Integer.parseInt(expression) > Simple.maxInt) return Simple.maxInt;
            else if (Integer.parseInt(expression) < Simple.minInt) return Simple.minInt;
            else return Integer.parseInt(expression);}
        catch (Exception ignored){
        }

        return null;

    }

    /**
     * inputCMD function is let user input those commands
     */
    // Use for input command, but just model, Application will be call this
    public void inputCMD() {

        Scanner inputLine = new Scanner(System.in);
        String input;

        while(inputLine.hasNextLine()){

            input = inputLine.nextLine();
            if (input != null){
                if (input.equals("quit")) System.exit(0);

                data.storeCommand(input);

            }

        }

        inputLine.close();
    }

}